/* Created and copyrighted by Zachary J. Fields. Offered as open source under the MIT License (MIT). */

#ifndef CACHE_SERIAL_H
#define CACHE_SERIAL_H

#include <cstddef>
#include <cstdint>

#include <deque>
#include <thread>

#include "ByteCache.h"
#include "Stream.h"

namespace serial_wiring {

/*!
 * \brief CacheSerial caches bytes received via the Stream interface
 *
 * CacheSerial provides a facility for polling applications to consume
 * bytes, as opposed to passing them directly to the IO layer of the
 * underlying operation system (i.e. BLE, Bluetooth, Network, UART,
 * etc...). Consequently, this will provide an API surface for language
 * bindings to access serial streams generated by the RemoteDevice class,
 * as well as inject responses received from the hardware. An example
 * would be to interact with the Bluetooth antenna on an Android device
 * via the Android API, and forwarding the byte stream to the RemoteDevice.
 */
class CacheSerial : public ByteCache, public Stream {
  public:
    CacheSerial (
        void
    ) :
        _uponBytesAvailable(nullptr),
        _uponBytesAvailable_context(nullptr),
        _uponCachedBytes(nullptr),
        _uponCachedBytes_context(nullptr)
    {}
    
  protected:
    inline
    size_t
    _available (
        void
    ) const override {
        return _rx.size();
    }

    inline
    void
    _begin (
        void
    ) override {
        _rx.clear();
        _tx.clear();
    }

    inline
    void
    _cacheByte (
        uint8_t byte_
    ) override {
        _rx.push_back(byte_);
        if ( _uponBytesAvailable ) { std::thread(_uponBytesAvailable, _uponBytesAvailable_context).detach(); }
    }

    inline
    void
    _end (
        void
    ) override {
        // Preserve outstanding bytes, but minimize space requirement
        _rx.shrink_to_fit();
        _tx.shrink_to_fit();

        // Detach any callbacks from `Stream` interface
        _uponBytesAvailable = nullptr;
        _uponBytesAvailable_context = nullptr;
        _uponCachedBytes = nullptr;
        _uponCachedBytes_context = nullptr;
    }

    inline
    void
    _flush (
        void
    ) override {
        // Manually call callback on ByteCache interface
        if ( !_tx.empty() ) { _uponCachedBytes(_uponCachedBytes_context); }
        _tx.clear();
    }

    inline
    int
    _read (
        void
    ) override {
        int result = 0;

        if ( !_rx.empty() ) {
            result = _rx.front();
            _rx.pop_front();
        }

        return result;
    }

    inline
    int
    _readCachedByte (
        void
    ) override {
        int result = 0;

        if ( !_tx.empty() ) {
            result = _tx.front();
            _tx.pop_front();
        }

        return result;
    }

    inline
    void
    _registerCachedBytesCallback (
        serial_event_t uponCachedBytes_,
        void * context_ = nullptr
    ) override {
        _uponCachedBytes = uponCachedBytes_;
        _uponCachedBytes_context = context_;
    }

    inline
    void
    _registerSerialEventCallback (
        serial_event_t uponBytesAvailable_,
        void * context_ = nullptr
    ) override {
        _uponBytesAvailable = uponBytesAvailable_;
        _uponBytesAvailable_context = context_;
    }

    inline
    size_t
    _size (
        void
    ) const override {
        return _tx.size();
    }

    inline
    void
    _write (
        uint8_t byte_
    ) override {
        _tx.push_back(byte_);
        if ( _uponCachedBytes ) { std::thread(_uponCachedBytes, _uponCachedBytes_context).detach(); }
    }

  private:
    std::deque<uint8_t> _rx;
    std::deque<uint8_t> _tx;
    serial_event_t _uponBytesAvailable;
    void * _uponBytesAvailable_context;
    serial_event_t _uponCachedBytes;
    void * _uponCachedBytes_context;
};

}  // namespace serial_wiring

#endif // CACHE_SERIAL_H

/* Created and copyrighted by Zachary J. Fields. Offered as open source under the MIT License (MIT). */
